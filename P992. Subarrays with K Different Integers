# - idea: sliding window, iterate each item, add to hashtable, 
# maintain subarray with k different elements with far and near left points; 
# if len(counter) > k, delete near ele counter, set near = near + 1, far = near
# if len(counter) == k, move near pointer as right as it can, res += near - far + 1

# time O(n)
# space O(K)

class Solution(object):
    def subarraysWithKDistinct(self, A, K):
       
        dic = collections.defaultdict(int) # key:ele, value : count
        near = 0
        far = 0
        res = 0
        
        for ele in A:
            dic[ele] += 1
            
            if len(dic) > K:
                del dic[A[near]]
                near += 1
                far = near
                
            if len(dic) == K:
                while dic[A[near]] > 1:
                    dic[A[near]] -= 1
                    near += 1
      
                res += near - far + 1
        return res
            
        
 
