# dfs
# time O(mn)
# space o(mn)

# the ball won't stop until hit the wall (this is our recursion point)

class Solution(object):
    def hasPath(self, maze, start, destination):
        self.end = destination
        self.visited = set()
        return self.dfs(maze, start[0], start[1])
    
    def dfs(self, maze, i, j):
        if i == self.end[0] and j == self.end[1]:
            return True
        
        if (i, j) in self.visited:
            return False
        
        self.visited.add((i, j))
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            x = i
            y = j
            while 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[0]) and maze[x + dx][y + dy] == 0:
                x = x + dx
                y = y + dy
            if self.dfs(maze, x, y):
                return True
        return False
            
            

# bfs
# time O(mn * max(m, n)
# space o(mn)

class Solution(object):
    def hasPath(self, maze, start, destination):
        """
        :type maze: List[List[int]]
        :type start: List[int]
        :type destination: List[int]
        :rtype: bool
        """
        queue = collections.deque([start])
        visited = set()
        visited.add((start[0], start[1]))
        
        while queue:
            # 注意 1. i, j
            i, j = queue.popleft()
            if i == destination[0] and j == destination[1]:
                return True
            
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                # 注意 1. 每次方向开始时 x, y 初始值都是i, j
                x = i
                y = j
                while 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[0]) and maze[x + dx][y + dy] == 0:
                    x += dx
                    y += dy
                if (x, y) not in visited and maze[x][y] == 0:
                    queue.append((x, y))
                    visited.add((x, y))
        return False
                
        


