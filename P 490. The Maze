# bfs
# time O(mn)
# space o(mn)

class Solution(object):
    def hasPath(self, maze, start, destination):
        """
        :type maze: List[List[int]]
        :type start: List[int]
        :type destination: List[int]
        :rtype: bool
        """
        queue = collections.deque([start])
        visited = set()
        visited.add((start[0], start[1]))
        
        while queue:
            # 注意 1. i, j
            i, j = queue.popleft()
            if i == destination[0] and j == destination[1]:
                return True
            
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                # 注意 1. 每次方向开始时 x, y 初始值都是i, j
                x = i
                y = j
                while 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[0]) and maze[x + dx][y + dy] == 0:
                    x += dx
                    y += dy
                if (x, y) not in visited and maze[x][y] == 0:
                    queue.append((x, y))
                    visited.add((x, y))
        return False
                
        


# dfs
# time O(mn)
# space o(mn)

# the ball won't stop until hit the wall (this is our recursion point)

class Solution(object):
    def hasPath(self, maze, start, destination):
       
        def dfs(x, y, visited):
            if x == destination[0] and y == destination[1]:
                return True
            if (x, y) in visited:
                return False
            
            visited.add((x, y))
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                new_x = x
                new_y = y
                while 0 <= new_x + dx < len(maze) and 0 <= new_y + dy < len(maze[0]) and maze[new_x + dx][new_y + dy] == 0:
                    new_x += dx
                    new_y += dy
                if dfs(new_x, new_y, visited):
                    return True
            return False
       
        if not maze:
            return False
        visited = set()
        return dfs(start[0], start[1], visited)
        
