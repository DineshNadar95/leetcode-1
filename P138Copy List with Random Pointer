# 深拷贝要对每个点都新建一遍。ALL
# 使用hashtable，在这个hash表里，记录了老链表和新链表的每一组对应。这样先构造了一个纯next的链表，然后再次循环就能得到带random的链表了

# time o(n)
# space o(n)
"""
# Definition for a Node.
class Node:
    def __init__(self, val, next, random):
        self.val = val
        self.next = next
        self.random = random
"""
class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        if not head:
            return None
        
        dic = {}
        inter_node = head
        while inter_node:
            dic[inter_node] = Node(inter_node.val, None, None)
            inter_node = inter_node.next
        
        inter_node = head
        while inter_node:
            dic[inter_node].next = dic[inter_node.next] if inter_node.next else None
            dic[inter_node].random = dic[inter_node.random] if inter_node.random else None
            inter_node = inter_node.next
            
        return dic[head] if head else None
        
 # sol2
 # time O(n)
 # space O(1)
 1. 在原链表的每个节点后面拷贝出一个新的节点。
 2. 依次给新的节点的随机指针赋值，而且这个赋值非常容易 cur->next->random = cur->random->next。
 3. 断开链表可得到深度拷贝后的新链表。

举个例子来说吧，比如原链表是 1(2) -> 2(3) -> 3(1)，括号中是其 random 指针指向的结点，
那么这个解法是首先比遍历一遍原链表，在每个结点后拷贝一个同样的结点，但是拷贝结点的 random 指针仍为空，
则原链表变为 1(2) -> 1(null) -> 2(3) -> 2(null) -> 3(1) -> 3(null)。

然后第二次遍历，是将拷贝结点的 random 指针赋上正确的值，则原链表变为 1(2) -> 1(2) -> 2(3) -> 2(3) -> 3(1) -> 3(1)，注意赋值语句为：
cur->next->random = cur->random->next;
这里的 cur 是原链表中结点，cur->next 则为拷贝链表的结点，cur->next->random 则为拷贝链表的 random 指针。
cur->random 为原链表结点的 random 指针指向的结点，因为其指向的还是原链表的结点，所以我们要再加个 next，才能指向拷贝链表的结点。
最后再遍历一次，就是要把原链表和拷贝链表断开即可

"""
# Definition for a Node.
class Node(object):
    def __init__(self, val, next, random):
        self.val = val
        self.next = next
        self.random = random
"""
class Solution(object):
    def copyRandomList(self, head):
        """
        :type head: Node
        :rtype: Node
        """
        if not head:
            return None
        
        # copy node
        pointer = head
        while pointer:
            new = Node(pointer.val, None, None)
            new.next = pointer.next
            pointer.next = new
            pointer = pointer.next.next
        
        # set random 
        pointer = head
        while pointer:
            pointer.next.random = pointer.random.next if pointer.random else None
            pointer = pointer.next.next
        
        # seprate old and new list
        old_list = head
        new_list = head.next
        new_head = head.next
        while old_list:
            old_list.next = old_list.next.next
            new_list.next = new_list.next.next if new_list.next else None
            old_list = old_list.next
            new_list = new_list.next
        return new_head
        
        
            
            
        
