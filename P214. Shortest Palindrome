# brute force
# find the longest palindrome begin from index 0, then reverser the other substring and add to the begining of s
# 从字符串开头找到最大的回文子串，然后反转剩余的子串并附加到开头。
# time O(n^2)
# space O(n)

class Solution(object):
    def shortestPalindrome(self, s):
        
        if len(s) == 1 or s == s[::-1]:
            return s
        
        res = ''
        for i in range(len(s)):
            if s[:i] == s[:i][::-1]:
                res = s[i:][::-1] + s
        return res
            
            
# sol2 
# time O(n)
# space O(n)
记原始字符串为s，s的反转字符串为rev_s。
构造字符串l = s + '#' + rev_s，其中'#'为s中不会出现的字符，添加'#'是为了处理输入为空字符串的情形。
对字符串l执行KMP算法，可以得到“部分匹配数组”p（也称“失败函数”）



