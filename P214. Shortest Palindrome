# brute force
# find the longest palindrome begin from index 0, then reverser the other substring and add to the begining of s
# 从字符串开头找到最大的回文子串，然后反转剩余的子串并附加到开头。
# time O(n^2)
# space O(n)

class Solution(object):
    def shortestPalindrome(self, s):
        
        if len(s) == 1 or s == s[::-1]:
            return s
        
        res = ''
        for i in range(len(s)):
            if s[:i] == s[:i][::-1]:
                res = s[i:][::-1] + s
        return res
            
            
# sol2 divide and conquer
# time O(n^2)
# space O(n)

The Idea is simple, we use i to compare character from end of s and beginning of s. If it's equal, increment i by 1.
So we can use i-len(s) to divide s in two parts. The first part is that we don't know it's Palindrome. 
The second part its that we know for sure its the suffix of result and it may need reversed and insert at beginning of result.

The fun part is this: s[::-1][:len(s)-i]
if len(s)-i is 0, it will eliminate as '', otherwise it equals reversed(s[len(s) - i:])


class Solution(object):
    def shortestPalindrome(self, s):

        
        if not s or len(s) == 1:
            return s
        
        i = 0
        for j in range(len(s) - 1, -1, -1):
            if s[i] == s[j]:
                i += 1
        if i == len(s):
            return s
        # s[:i] s[i:]
        # ab cdba
        # abdc + ab + cdba
        return s[i:][::-1] + self.shortestPalindrome(s[:i]) + s[i:]
