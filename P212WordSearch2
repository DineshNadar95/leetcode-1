# 首先建立字典树，字典树从root开始。利用字母的公共前缀建树。
# 遍历字母矩阵，将字母矩阵的每个字母，从root开始dfs搜索，搜索到底部时，将字符串存入答案返回即可。


1. time complexity 
      construct trie:O(len(words) * max(len(word))
      dfs search: O(mn * 4 ^ l, l is the max length of word) -> upper bound to (mn * mn)
      
2. space complextiy
      trie O(trie node)
      dfs O(mn)
     
node: 找到单词之后，为了避免重复，cur_node.is_word = False

class TrieNode(object):
    def __init__(self):
        self.children = {}
        self.is_word = False
        
class Trie(object):
    def __init__(self):
        self.root = TrieNode()
        
    def insert(self, word):
        cur = self.root
        for char in word:
            if char not in cur.children:
                cur.children[char] = TrieNode()
            cur = cur.children[char]
        cur.is_word = True
        


class Solution(object):
    def findWords(self, board, words):
        
        # build trie
        trie = Trie()
        for w in words:
            trie.insert(w)
            
        self.res = []
        for i in range(len(board)):
            for j in range(len(board[0])):
                self.visited = set()
                self.dfs(board, i, j, '',  trie.root)
                
        return self.res
    
    def dfs(self, board, x, y, cur_path, cur_node):
        if cur_node.is_word:
            self.res.append(cur_path)
            cur_node.is_word = False
        
        if x < 0 or x >= len(board) or y < 0 or y >= len(board[0]) or (x, y) in self.visited or board[x][y] not in cur_node.children.keys():
            return 
        
        self.visited.add((x, y))
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            new_x = x + dx
            new_y = y + dy
            self.dfs(board, new_x, new_y, cur_path + board[x][y], cur_node.children[board[x][y]])
            
        self.visited.remove((x, y))
            
        
        
        
