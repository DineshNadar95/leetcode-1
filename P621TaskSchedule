# freq(A) = k
# task分成k-1组， 每组n + 1个
# (k - 1) * (n + 1) + p (和A有相同frequency任务的数量，如果没有则为1）
# lower bound: schedule all tasks without idle

# time O(n)
# space O(n)

  class Solution(object):
    def leastInterval(self, tasks, n):
        """
        :type tasks: List[str]
        :type n: int
        :rtype: int
        """
        count = collections.Counter(tasks)
        counts = count.values()
        max_count = max(counts)
        res = (max_count - 1) * (n + 1)
        for count in counts:
            if count == max_count:
                res += 1
            else:
                res += 0
        return max(len(tasks), res)
        
# in order, task << cooldown

import collections
def taskSchedule(tasks, n):
    
    last_time = collections.defaultdict(int)
    least_time = 0
    
    for task in tasks:
        if task not in last_time or last_time[task] + n < least_time:
            least_time += 1
            last_time[task] = least_time
        else:
            least_time = last_time[task] + n 
            least_time += 1
            last_time[task] = least_time
    return least_time
            
tasks = [1, 2, 3, 1, 1, 2]
# 1 2 3 - 1 - - - 1 2
n = 3
print(taskSchedule(tasks, n))


## in order, task >> cooldown

# 我也遇到这个task scheduler的问题了 我的followup是用queue，queue里就存last cooldown range的job，
每次遇到job遍历一遍这个queue就好了，因为cooldown是常数 所以还算是O(N)

记录一个cooldown内做过的任务的时间，然后动态删除已经过期的任务。这样时间复杂度可能会增加到O(kn)，cooldown长度*task个数，但空间复杂度能够降低。
# follow up 2, keep original order and task >> n
# queue keep the tasks or idle in the last cooldown 
# the size of queue is n
def leastInterval2(tasks, n):
    least_time = 0
    queue = []
    for task in tasks:
        if task not in queue:
            queue.append(task)
            least_time += 1
            if len(queue) > n:
                queue.pop(0)
            
        else:
            # add queue only len(queue) = n + 1
            while len(queue) <= n:
                queue.append('-')
                least_time += 1
            # add queue only when interval between last[task] >= n
            while queue.pop(0) != task:
                queue.append('-')
                least_time += 1
            queue.append(task)
            least_time += 1
            
    return least_time

print(leastInterval2([1, 2, 3, 1, 1, 2], 3))
                
tasks = [1, 2, 3, 1, 1, 2]
# 1 2 3 - 1 - - - 1 2
n = 3
print(taskSchedule(tasks, n))
