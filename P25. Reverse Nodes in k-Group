# 思路:
    recursion 递归
    # if len < k, return head
    
    recursion part, first k reverse, after first k, call recursion fun, return head
    # revserse first nodes at a time and return new head, return new_h, new_t
    # new_t.next = reverseKGraoup(after k)
    
    
# time O(n)
# space O(n/k)

class Solution(object):
    def reverseKGroup(self, head, k):
        
        cur = head
        count = 0
        
        while cur and count < k:
            cur = cur.next 
            count += 1
            
        # count == k
        if count < k:
            return head
    
       
        nxt_head = cur 
        new_head, new_tail = self.reverse_k(head, k)
        new_tail.next = self.reverseKGroup(nxt_head, k)
        return new_head
    
    
    def reverse_k(self, head, k):
        prev = None
        nxt = None
        cur = head
        
        while k:
            #print(cur, k)
            nxt = cur.next 
            cur.next = prev
            prev = cur
            cur = nxt 
            
            k -= 1
            #print(k, cur) 
            
        return prev, head
            
