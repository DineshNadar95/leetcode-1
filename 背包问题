# 0-1 背包
时间复杂度:O(MN)，空间复杂度:O(MN)，可以用滚动数组优化空间至O(N)

题目: 有N件物品和一个容量为V的背包。第i物品的重量是c[i],价值是w[i]。求解将哪些物品装入背包可使价值总和最大
这是最基础的背包问题，特点是：每种物品只有一件，可以选择放或者不放

用子问题定义状态：即dp[i][j]表示前i件物品放入一个容量为j的背包可以获得的最大价值。则其状态转移方程为：
dp[i][j] = max{dp[i - 1][j], dp[i - 1][j - c[i]] + w[i]}

这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来。这里详细解释一下：

将前i件物品放入容量为j的背包中这个子问题，若只考虑第i件物品的策略（放或者不放），那么就可以转换为一个只牵扯前i-1件物品的问题。
如果不放第i件物品，那么问题就转换为前i-1件物品放入容量为j的背包中的最大价值，价值为dp[i - 1][j]
如果放入第i件物品，那么问题就转换为前i-1件物品放入容量为j-c[i]的背包中，此时能获得的最大价值是dp[i-1][j-c[i]],再加上放入第i件物品获得的价值w[i]

优化空间复杂度
先考虑一下上面的状态转移方程如何实现，肯定有一个主循环i = 1...N,每次算出来二维数组dp[i][0..V]的所有值。
那么如果只用一个数组f[0...V],能不能保证第i次循环结束后f[v]就是我们定义的状态f[i][v]呢？f[i][v]是由f[i-1][v]和f[i-1][v-c[i]]两个子问题递推而来，
能否保证在推f[i][v]时（也即在第i次主循环中推f[v]时）能够得到f[i-1][v]和f[i-1][v-c[i]]的值呢？
事实上，这要求在每次主循环中我们以v=V...0的顺序推f[v]，这样才能保证推f[v]时f[v-c[i]]保存的是状态f[i-1][v-c[i]]的值。伪代码如下：

for i  in 0 ... N
    for  v = V ... 0
        f[v] = max{f[v], f[v-c[i]] + w[i]}



# 多重背包



# 完全背包
