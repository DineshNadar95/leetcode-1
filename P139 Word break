# brute force 
# time O(n^n) eg: 'aaaaa'
# spce O(n)，递归的深度,递归在内存中同时存在的最大次数

class Solution(object):
    def wordBreak(self, s, wordDict):
        
        return self.dfs(s, 0, wordDict)
    
    def dfs(self, s, index, wordDict):
        if index == len(s):
            return True
        
        for j in range(index, len(s)):
            if s[index : j + 1] in wordDict and self.dfs(s, j + 1, wordDict):
                return True
        return False
    
        
# problem with sol1, many subproblems are redundant, we were calling recursive funtions many times for a particular string
# so we use hash table to store the result of subproblems that we've calculated.

# sol2 recursion time O(n^2), space O(n) (memo O(n), max depth of recursion is O(n))
# key: start index, value: res of the recursive function for this start index

class Solution(object):

    def wordBreak(self, s, wordDict):
        # s = "leetcode", wordDict = ["leet", "code"]
        word_dic = set(wordDict)
        return self.dfs(s, 0, {}, word_dic)
    
    def dfs(self, s, start, memo, word_dic):
        if start in memo:
            return memo[start]
        
        if start == len(s):
            memo[start] = True
            return True
        
        for end in range(start + 1, len(s) + 1):
            if s[start : end] in word_dic and self.dfs(s, end, memo, word_dic):
                memo[start] = True
                return memo[start]
        memo[start] = False
        return memo[start]
        

# sol3: dp
# dp[i] means s[:i] can be segmented into words in the wordDicts
# time O(n^2)
# space O(n)

class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        
        dp = [False] * (len(s) + 1)
        dp[0] = True
        
        for i in range(len(dp)):
            # 前i个数 s[:i]
            if dp[i]:  
                for j in range(i + 1, len(dp)):
                    if s[i:j] in wordDict:
                        dp[j] = True
        return dp[-1]
        
        
 # follow up 1 只输出一组解
 # 思路用dp，因为只输出一组解，所以不需要用dfs
 def wordBreak(s, dic):
    
    dp = [False] * (len(s) + 1)
    dp[0] = True
    words = [''] * (len(s) + 1)
    # vaild path for s[:j]
   
    for i in range(len(s)):
        for j in range(i + 1, len(dp)):
            if dp[i] and s[i : j] in dic:
                dp[j] = True
                if not words[i]:
                    words[j] = s[i : j]
                else:
                    words[j] = words[i] + ' ' + s[i : j]
    print(words)
                    
    if dp[-1]:
        return words[-1]
    else:
        return ''
    
s = "catsanddog"

dic = ["cat", "cats", "and", "sand", "dog"]
print(wordBreak(s, dic))
                                     
 
 
 # follow up 2 输出最小的分割次数
import sys
class Solution(object):
    def wordBreak(self, s, dic):
        
        return self.dfs(s, dic, 0, len(s) - 1, {})
    
    
    def dfs(self, s, dic, start, end, memo):
        if (start, end) in memo:
            return memo[(start, end)]
        
        res = sys.maxsize
        if s[start : end + 1] in dic:
            memo[(start, end)] = 1
            return 1
        
        for j in range(start, end):
            if s[start: j + 1] in dic:
                res = min(res,  1 +  self.dfs(s, dic, j + 1, end, memo))
                
        memo[(start, end)] = res
        return res
                

s = "pineapplepenapple"
dic =["apple", "pen", "applepen", "pine", "pineapple"]

test = Solution()
print(test.wordBreak(s, dic))
                            
 
 
 
 
  
       
