# brute force 
# time (n^n)
# spce O(n)

class Solution(object):
    def wordBreak(self, s, wordDict):
        wordDict = set(wordDict)
        return self.dfs(s, wordDict, 0)
    
    def dfs(self, s, wordDict, i):
        if i == len(s):
            return True
        
        for j in range(i, len(s)):
            if s[i:j + 1] in wordDict and self.dfs(s, wordDict, j + 1):
                return True
            
        return False
        
# sol2 recursion time O(n^2), space O(n)
 # memo if s[start:end] can be segmented into a space-separated sequence of one or more dictionary words.
 
class Solution(object):
    def wordBreak(self, s, wordDict):
        return self.dfs(s, 0, len(s), set(wordDict), {})
    
    def dfs(self, s, start, end, wordDict, memo):
        if (start, end) in memo:
            return memo[(start, end)]
            
         #不要遗忘
        if s[start:end] in wordDict:
            memo[(start, end)] = True
            return True
        for j in range(start, end):
            if s[start : j + 1] in wordDict and self.dfs(s, j + 1, end, wordDict, memo):
                memo[(start, end)] = True
                return True
                
        memo[(start, end)] = False
        return False

# sol3: dp
# dp[i] means s[:i] can be segmented into words in the wordDicts
# time O(n^2)
# space O(n)

class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        
        dp = [False] * (len(s) + 1)
        dp[0] = True
        
        for i in range(len(s)):
            # 前i个数 s[:i]
            if dp[i]:  
                # s[i: ]
                for j in range(i + 1, len(dp)):
                    if s[i:j] in wordDict:
                        dp[j] = True
        return dp[-1]
        
        
 # follow up 1 只输出一组解
 # 思路用dp，因为只输出一组解，所以不需要用dfs
 def wordBreak(s, dic):
    
    dp = [False] * (len(s) + 1)
    dp[0] = True
    words = [''] * (len(s) + 1)
    # vaild path for s[:j]
   
    for i in range(len(s)):
        for j in range(i + 1, len(dp)):
            if dp[i] and s[i : j] in dic:
                dp[j] = True
                if not words[i]:
                    words[j] = s[i : j]
                else:
                    words[j] = words[i] + ' ' + s[i : j]
    print(words)
                    
    if dp[-1]:
        return words[-1]
    else:
        return ''
    
s = "catsanddog"

dic = ["cat", "cats", "and", "sand", "dog"]
print(wordBreak(s, dic))
                                     
 
 
 # follow up 2 输出最小的分割次数
import sys
class Solution(object):
    def wordBreak(self, s, dic):
        
        return self.dfs(s, dic, 0, len(s) - 1, {})
    
    
    def dfs(self, s, dic, start, end, memo):
        if (start, end) in memo:
            return memo[(start, end)]
        
        res = sys.maxsize
        if s[start : end + 1] in dic:
            memo[(start, end)] = 1
            return 1
        
        for j in range(start, end):
            if s[start: j + 1] in dic:
                res = min(res,  1 +  self.dfs(s, dic, j + 1, end, memo))
                
        memo[(start, end)] = res
        return res
                

s = "pineapplepenapple"
dic =["apple", "pen", "applepen", "pine", "pineapple"]

test = Solution()
print(test.wordBreak(s, dic))
                            
 
 
 
 
  
       
