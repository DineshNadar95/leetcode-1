# bucket sort, since 0 <= workers[i][j], bikes[i][j] < 1000
# max distance is 2000

# m, len(worders)
# n, len(bikes)
# time O(mn)
# space O(m + n)

class Solution(object):
    def assignBikes(self, workers, bikes):
        """
        :type workers: List[List[int]]
        :type bikes: List[List[int]]
        :rtype: List[int]
        """
        res = [-1] * len(workers)
        visited_bikes = [False] * len(bikes)
        dis = [[]  for _ in range(1999)]
        for i, [x, y] in enumerate(workers):
            for j, [x1, y1] in enumerate(bikes):
                dist = abs(x - x1) + abs(y - y1)
                dis[dist].append((i, j))
        
        #print(dis)
        count = 0
        for dis_l in dis:
            for w, b in dis_l:
                if res[w] == -1 and not visited_bikes[b]:
                    res[w] = b
                    visited_bikes[b] = True
                    count += 1
                    if count == len(workers):
                        break
        return res
            
                




# sort
# traverse all the pairs
# time O(mn*lgmn)
# space O(mn)

class Solution(object):
    def assignBikes(self, workers, bikes):
        """
        :type workers: List[List[int]]
        :type bikes: List[List[int]]
        :rtype: List[int]
        """
        distance = []
        for i in range(len(workers)):
            for j in range(len(bikes)):
                dis = abs(workers[i][0] - bikes[j][0]) + abs(workers[i][1]- bikes[j][1])
                distance.append((dis, i, j))
        distance.sort()
        
        
        res = [-1] * len(workers)
        bike_set = set()
       
        for dis, i, j in distance:
            if res[i] == -1 and j not in bike_set:
                res[i] = j
                bike_set.add(j)
                if len(bike_set) == len(workers):
                    break
        return res
            
