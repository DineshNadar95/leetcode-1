
# 求最短路径的题目一般还是BFS比DFS靠谱
# idea: bfs travsesal, but we need to travse all the different paths to each point
# put point and steps into queue, while queue, pop out, try four directions, if x + dx and y + dy is 0, continue roll, else
stop, check the current step, put current point into visited, if the current is not destination, put into queue again

# time O(m*n * max(m, n)), each points, max road length is max(m, n)
# space O(mn)

directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
class Solution(object):
    def shortestDistance(self, maze, start, destination):
      
        visited = {}
        queue = collections.deque([(start[0], start[1], 0)])
        visited[(start[0], start[1])] = 0
        
        while queue:
            i, j, d = queue.popleft()
            for dx, dy in directions:
                x = i
                y = j
                step = d
                while 0 <= x + dx < len(maze) and 0 <= y + dy < len(maze[0]) and maze[x + dx][y + dy] == 0:
                    x += dx
                    y += dy
                    step += 1
                if (x, y) not in visited or (x, y) in visited and visited[(x, y)] > step:
                    visited[(x, y)] = step
                    if (x, y) != (destination[0], destination[1]) and maze[x][y] == 0:
                        queue.append((x, y, step))
        return visited.get((destination[0], destination[1]), -1)
                    
