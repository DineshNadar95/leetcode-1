# brute force 
# O(n^6)

# 那么我们可以先确定中间那个子数组的位置，这样左右两边的子数组的位置范围就缩小了
# 中间子数组的起点不能是从开头到结尾整个区间，必须要在首尾各留出k个位置给其他两个数组。
# 一旦中间子数组的起始位置确定了，那么其和就能通过累加和数组快速确定。那么现在就要在左右两边的区间内分别找出和最大的子数组

left[i]表示在区间[0, i]范围内长度为k且和最大的子数组的起始位置
right[i]表示在区间[i, n - 1]范围内长度为k且和最大的子数组的起始位置

这两个dp数组各需要一个for循环来更新，left数组都初始化为0，前k个数字没办法，肯定起点都是0，
变量total初始化为前k个数字之和，然后从第k+1个数字开始，每次向前取k个，
利用累加和数组sums快速算出数字之和，跟total比较，如果大于total的话，那么更新total和left数组当前位置值，
否则的话left数组的当前值就赋值为前一位的值。同理对right数组的更新也类似，
total初始化为最后k个数字之和，然后从前一个数字向前遍历，如果大于total，更新total和right数组的当前位置，
否则right数组的当前值就赋值为后一位的值。一旦left数组和right数组都更新好了，那么就可以遍历中间子数组的起始位置了，
然后我们可以通过left和right数组快速定位出左边和右边的最大子数组的起始位置，并快速计算出这三个子数组的所有数字之和，
用来更新全局最大值mx，如果mx被更新了的话，记录此时的三个子数组的起始位置到结果res中，

