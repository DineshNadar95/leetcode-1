# BFS
# time O(v+e)
# space O(v)
方法也是使用了字典保存每一个对应关系。当新构造出一个节点之后，必须同时把它放到字典中保存，这个很重要。
另外就是每遍历到一个节点时，都要把它的所有邻居放到队列中。

class Solution:
    def cloneGraph(self, node):
        visited = {}
        node_copy = Node(node.val, [])
        visited[node] = node_copy
        queue = collections.deque([node])
        
        while queue:
            cur_node = queue.popleft()
            for neighbor in cur_node.neighbors:
                if neighbor not in visited:
                    visited[neighbor] = Node(neighbor.val, [])
                    queue.append(neighbor)
                visited[cur_node].neighbors.append(visited[neighbor])
        return node_copy
        
# DFS
time O(v + e), space depends on the depth of the graph
class Solution:
    def cloneGraph(self, node):
        return self.dfs(node, {})
 
    def dfs(self, node, visited):
        if not node:
            return None
        if node in visited:
            return visited[node]
        
        node_copy = Node(node.val, [])
        visited[node] = node_copy
        for neighbor in node.neighbors:
            neighbor_copy = self.dfs(neighbor, visited)
            if neighbor_copy:
                node_copy.neighbors.append(neighbor_copy)
        return node_copy


# DFS iterative
class Solution:
    def cloneGraph(self, node):
        visited = {}
        node_copy = Node(node.val, [])
        visited[node] = node_copy
        stack = [node]
        while stack:
            cur_node = stack.pop()
            if cur_node:
                for neighbor in cur_node.neighbors:
                    if neighbor not in visited:
                        visited[neighbor] = Node(neighbor.val, [])
                        stack.append(neighbor)
                    visited[cur_node].neighbors.append(visited[neighbor])
        return node_copy
                       
