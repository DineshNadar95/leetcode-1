# sol1 brute-force
# time O((len(s)-len(p))*len(p)) = O(n^2)


# sol2 sliding window + counter
# time O(len(s)), space O(len(p))

class Solution(object):
    def findAnagrams(self, s, p):
       
        m = len(s)
        n = len(p)
        if m < n:
            return []
        
        # key:char in p, vlaue:count
        c_p = collections.Counter(p)
        c_s = collections.Counter(s[:n - 1]) # n - 2 - 0 + 1 = n - 1
        i = 0
        res = []
        for j, char in enumerate(s[n - 1:]):
            c_s[char] += 1
            if c_s == c_p:
                res.append(i)
            
            if c_s[s[i]] == 1:
                del c_s[s[i]]
            else:
                c_s[s[i]] -= 1
            i += 1
                
        return res
                
