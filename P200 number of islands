# DFS
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        # sanity check
        if not grid:
            return 0
        
        count = 0
        rows = len(grid)
        cols = len(grid[0])
        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == '1':
                    count += 1
                    self.dfs(grid, i, j, rows, cols)
        return count 
    
    def dfs(self, grid, x, y, rows, cols):
        # base case
        if x < 0 or x >= rows or y < 0 or y >= cols or grid[x][y] == '0':
            return
        # recursive rule
        grid[x][y] = '0'
        directions = [[-1, 0], [1, 0], [0, 1], [0, -1]]
        for direction in directions:
            neighbor_x = direction[0] + x
            neighbor_y = direction[1] + y
            self.dfs(grid, neighbor_x, neighbor_y, rows, cols)
            
            
    # BFS
    class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        # sanity check
        if not grid:
            return 0
        
        count = 0
        rows, cols = len(grid), len(grid[0])
        location_set = set([(i, j) for i in range(rows) for j in range(cols) if grid[i][j] == '1'])
        directions = [[-1, 0], [1, 0], [0, 1], [0, -1]]
        while location_set:
            count += 1
            queue = collections.deque([location_set.pop()])
            while queue:
                i, j = queue.popleft()
                for direction in directions:
                    neighbor_i = i + direction[0]
                    neighbor_j = j + direction[1]
                    if (neighbor_i, neighbor_j) in location_set:
                        location_set.remove((neighbor_i, neighbor_j))
                        queue.append((neighbor_i, neighbor_j))
        return count
        
