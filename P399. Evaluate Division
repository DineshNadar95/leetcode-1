# sol1 build graph + dfs q:query; e:equation
# time O(q(v + e)), worst case e is v^2
# space O(v + q)

import collections

class Solution(object):
    def calcEquation(self, equations, values, queries):
        
        # build graph
        # dfs 
        graph = collections.defaultdict(dict)
        for i in range(len(equations)):
            n1, n2 = equations[i]
            val = values[i]
            graph[n1][n2] = val      # n1/n2 = val
            graph[n2][n1] = 1.0 / val
        
        res = []
        for n1, n2 in queries:
            if n1 not in graph:
                res.append(-1)
            else:
                cur_r = self.dfs(graph, n1, n2, 1, set())
                res.append(cur_r)
        return res
    
    def dfs(self, graph, n1, target, cur_val, visited):
        if n1 in visited:
            return -1
        
        if n1 == target:
            return cur_val
        
        visited.add(n1)
        res = -1
        for n2, w in graph[n1].items():
            cur_res = self.dfs(graph, n2, target, cur_val * w, visited)
            if cur_res > 0:
                return cur_res
        return res
                
            
