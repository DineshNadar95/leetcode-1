# counter 
# max counter * 2 - 1 > len(s)
# heap reorganize
# time O(nlgA) = O(n)
# space O(A)
那么我们还是要统计每个字符串出现的次数啊，这里使用HashMap来建立字母和其出现次数之间的映射。
由于我们希望次数多的字符排前面，可以使用一个最大堆，将次数当做排序的key，那么就把次数和其对应的字母组成一个pair，放进最大堆中自动排序。
这里其实有个剪枝的trick，如果某个字母出现的频率大于总长度的一半了，那么必然会有两个相邻的字母出现。
这里博主就不证明了，感觉有点像抽屉原理。所以我们在将映射对加入优先队列时，先判断下次数，超过总长度一半了的话直接返回空串就行了。

接下来，我们每次从优先队列中取队首的两个映射对儿处理，
因为我们要拆开相同的字母，这两个映射对儿肯定是不同的字母，我们可以将其放在一起，
之后我们需要将两个映射对儿中的次数自减1，如果还有多余的字母，即减1后的次数仍大于0的话，将其再放回最大堆。
由于我们是两个两个取的，所以最后while循环退出后，有可能优先队列中还剩下了一个映射对儿，此时将其加入结果res即可。
而且这个多余的映射对儿一定只有一个字母了，因为我们提前判断过各个字母的出现次数是否小于等于总长度的一半，按这种机制来取字母，
不可能会剩下多余一个的相同的字母，参见代码如下：

from collections import Counter
from heapq import * 
class Solution(object):
    def reorganizeString(self, S):
        """
        :type S: str
        :rtype: str
        """
        counter = Counter(S)
        max_common = counter.most_common(1)[0][1]
        if max_common * 2 - 1 > len(S):
            return ''
        heap = []
        for char, times in counter.items():
            heappush(heap, (-times, char))
            
        res = ''
        new_times = 0
        new_char = ''
        while heap:
            neg_times, char = heappop(heap)
            res += char
            if new_times < 0:
                heappush(heap, (new_times, new_char))
            # this make sure same chars are not adjacent to each other
            neg_times += 1
            new_times = neg_times
            new_char = char
        
        return res
        
        
        
     
