# greedy
# time O(n + AlgA) A:size of alphebet
# space O(n)

将字母按照出现次数从大到小排序。
每次优先选择剩余次数最多，且与新字符串末尾字符串不重复的字符，排在末尾。
若某次选择无法找出这样的字符，则返回空串。
class Solution(object):
    def reorganizeString(self, S):
        """
        :type S: str
        :rtype: str
        """
        count = collections.Counter(S)
        res = '#'
        
        while True:
            stop = True
            for ele, c in count.most_common():
                if c > (len(S) + 1)/2:
                    return ''
                if res[-1] != ele:
                    res += ele
                    count[ele] -= 1
                    if count[ele] == 0:
                        del count[ele]
                    stop = False
                    break
            if stop == True:
                break
        if len(res) == len(S) + 1:
            return res[1:]
        else:
            return ''
            

# counter 
# max counter * 2 - 1 > len(s)
# heap reorganize
# time O(nlgA) = O(n)
# space O(A)

# 可以用
from collections import Counter
from heapq import * 
class Solution(object):
    def reorganizeString(self, S):
        """
        :type S: str
        :rtype: str
        """
        counter = Counter(S)
        max_common = counter.most_common(1)[0][1]
        if max_common * 2 - 1 > len(S):
            return ''
            
        heap = []
        for char, times in counter.items():
            heappush(heap, (-times, char))
            
        res = ''
        
        new_times = 0
        new_char = ''
        while heap:
            neg_times, char = heappop(heap)
            res += char
            if new_times < 0:
                heappush(heap, (new_times, new_char))
            # this make sure same chars are not adjacent to each other
            neg_times += 1
            new_times = neg_times
            new_char = char
        
        return res
        
        
        
     
