'''
main function:
update:
get topk

# sol1: heap + hashmap
# initial heapify, time O(n)
# time: update : pop stock from heap, add new to heap, O(logn)/worst case O(n)


# sol2 : hashtable + double linked list
# initial hashtable, sort by values, O(nlgn) and build k size linked list, 
# smallest is head

# update: 
case 1: update one in top k
    remove the node from linked list
    compare from smallest
    insert/add
    
    2. not in top k
    compare from smallest O(k)
    insert/add O(1)

'''
# sol1, hashtable + heap
from heapq import * 
import collections
class StockSystem(object):
    def __init__(self, stocks):
        self.dic = {}  # key: name, val: stock node in heap
        self.heap = []
        for (stock, vol) in stocks:
            entry = [-vol, stock]
            self.heap.append(entry)
            self.dic[stock] = entry
            
        heapify(self.heap)
                
    def update(self, stock, vol):
        if stock in self.dic:
            self.dic[stock][0] -= vol
            heapify(self.heap)    
        else:
            new = [-vol, stock]
            heappush(self.heap, new)
            self.dic[stock] = new
                     
        
    def get_top_k(self, k):
        res = self.heap[:k]
        res = [[x[1], -x[0]] for x in res]
        return res
    

test = StockSystem([('Amazon', 500), ('Facebook',800), ('Google', 1000)])
print(test.get_top_k(2))
test.update('Amazon', 700)
print(test.get_top_k(2))
test.update('Microsoft', 2000)
print(test.get_top_k(2))

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
