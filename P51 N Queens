# brute force
# all possible ways, N^N (n queens and each have n possible positions)


# sol2: dfs with constraints
# using backtracking O(n!)

There could be the only one queen in a row and the only one queen in a column.
That means that there is no need to consider all squares on the board. One could just iterate over the columns.

class Solution(object):
    def solveNQueens(self, n):
        
        self.res = []
        self.dfs([-1] * n, 0, [])
        print(self.res)
        return self.res
    
    def dfs(self, cols, cur_queen, cur_path):
        if cur_queen == len(cols):
            self.res.append(cur_path)
            return 
        
        for i in range(len(cols)):
            cols[cur_queen] = i
            if self.valid(cols, cur_queen):
                tmp = '.' * len(cols)
                self.dfs(cols, cur_queen + 1, cur_path + [tmp[:i] + 'Q' + tmp[ i + 1 :]])
                
    def valid(self, cols, cur_queen):
        for i in range(cur_queen):
            if cols[i] == cols[cur_queen] or abs(cols[i] - cols[cur_queen]) == cur_queen - i:
                return False
        return True
            
