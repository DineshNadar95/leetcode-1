# subarray sum time O(n^2), space O(1)
# pay attention to corner cases

class Solution:
    def checkSubarraySum(self, nums: List[int], k: int) -> bool:
        # length < 2
        if len(nums) < 2:
            return False 
        
        # sum_ = 0
        for i in range(len(nums) - 1):
            if nums[i] + nums[i + 1] == 0:
                return True
        
        for left in range(len(nums)):
            # length of numbers >= 2
            sum_ = nums[left]
            for right in range(left + 1, len(nums)):
                sum_ += nums[right]
                # k != 0
                if k != 0 and sum_ % k == 0:
                    return True
        return False


# If k == 0, then search for any consecutive pair of 0s.
# Else, dict key:prefix sum mod by k, value :index 
# We will return True if we've seen a cumulative sum % k at least 2 indices before.
# This means that there is a subarray that has a sum(subarray) % k == 0 and that subarray contains at least 2 elements.

# time O(n)
# space O(k)
class Solution(object):
    def checkSubarraySum(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: bool
        """
        if k == 0:
            for i in range(len(nums) - 1):
                if nums[i] == 0 and nums[i + 1] == 0:
                    return True
            return False
        
        mod = {0:-1}
        cum_sum_mode_k = 0
        
        for i,n in enumerate(nums):
            cum_sum_mode_k = ((cum_sum_mode_k) + n) % k
            if cum_sum_mode_k in mod and i - mod[cum_sum_mode_k] > 1:
                return True
            if cum_sum_mode_k not in mod:
                mod[cum_sum_mode_k] = i
        return False
