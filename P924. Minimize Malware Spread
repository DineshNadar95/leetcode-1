# dfs
# time O(n^2), O(V + E), worst case E is n^2
# space O(n)

# 思路,
# step1: dfs color each node, nodes in the same connected component have the same color
# step2: count for each color
# step3: 遍历initials每一个点，找到没有相同颜色的点，找当前点color size大的,字母序小的点删除

class Solution(object):
    def minMalwareSpread(self, graph, initial):
        
        
        # step1 : color each node, each node in same connected component has the same color
        n = len(graph)
        self.color = collections.defaultdict(int)
        
        c = 0
        for i in range(n):
            if i not in self.color:
                self.dfs(graph, i, c)
                c += 1
        
        # step2: count each color, key: color. value: count
        count = collections.Counter(self.color.values())
        
        # step3: check unique initials
        uniques = collections.defaultdict(int) # key: color, value: count in initials
        for node in initial:
            uniques[self.color[node]] += 1
            
        # step4: 需要remove unique node with max color size and less alpha order 
        res = sys.maxsize
        for node in initial:
            if uniques[self.color[node]] == 1: 
                if res == sys.maxsize or count[self.color[node]] > count[self.color[res]] or (count[self.color[node]] == count[self.color[res]] and res > node):
                    #if res == 0:     
                    res = node

        if res == sys.maxsize:
            return min(initial)
        return res
            
            
        
    def dfs(self, graph, node, c):
        self.color[node] = c
        for j, nb in enumerate(graph[node]):
            if nb == 1 and j not in self.color:
                self.dfs(graph, j, c)
        
        
        
    
