# dfs
# time O(n^2), O(V + E), worst case E is n^2
# space O(n)

# 思路,
# step1, color each node 
# 2, size of each color
# 3. count ini color
# 4. return ans ( unique color count in ini, with greater component size and smaller index is res)


class Solution(object):
    def minMalwareSpread(self, graph, initial):
        
        # step1, using dfs to color graph
        color = {}
        n = len(graph)
        c = 0
        for i in range(n):
            if i not in color:
                self.dfs(color, graph, i, c)
                c += 1
        print(color)
        
        # 2, size of each color 
        size = collections.Counter(color.values())
        
        # 3, count ini color
        count_ini = collections.defaultdict(int)
        for ini in initial:
            count_ini[color[ini]] += 1
        
        # 4, ans
        res = sys.maxsize
        for ini in initial:
            c = count_ini[color[ini]]
            if c == 1:
                if res == sys.maxsize:
                    res = ini
                elif size[color[ini]] > size[color[res]] or (size[color[ini]] == size[color[res]] and res > ini):
                    res = ini
                    
        if res == sys.maxsize:
            return min(initial)
        return res
            
    def dfs(self, color, graph, node, c):
        color[node] = c
        for j, nb in enumerate(graph[node]):
            if nb == 1 and j not in color:
                self.dfs(color, graph, j, c)
        
        

    
