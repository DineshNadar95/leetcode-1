# method1, DP, O(n^2)
# method2, emumeration, O(n^2)

# so state variable is dp(s, e) indicates whether str[s, e] is palindromic

# state(s, e) is true:
# for s = e  
# for s + 1 = e,  if str[s] == str[e]
# for s + 2 <= e, if str[s] == str[e] && state(s + 1, e - 1) is true


class Solution(object):
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """
        if not s:
            return ''
        n = len(s)
        dp = [[False] * n for _ in range(n)]
        
        start = 0
        max_len = 1
        
        # Fill DP table for single char palindromes
        for i in range(n):
            dp[i][i] = True
        
        # Fill DP table for 2 char long palindromes
        for i in range(n - 1):
            if s[i] == s[i + 1]:
                dp[i][i + 1] = True
                start = i
                max_len = 2
        
        # Fill DP table for palindromes of every other length
        # starting from 3
        length = 3 
        while length <= n:
            for i in range(n - length + 1):
                j = i + length - 1
                if dp[i + 1][j - 1] == True and s[i] == s[j]:
                    dp[i][j] = True
                    max_len = length
                    start = i
            length += 1
        return s[start : start + max_len]
                    
        
    

# method2, emumeration, O(n^2) from middle to two ends
# 中心线枚举, 每个点作为中心线时找到的最长的回文串
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if not s:
            return ''
        
        longest = ''
        for middle in range(len(s)):
            # case: aba
            sub = self.find_palindrome_from(s, middle, middle)
            if len(sub) > len(longest):
                longest = sub
             # case: abba
            sub = self.find_palindrome_from(s, middle, middle + 1)
            if len(sub) > len(longest):
                longest = sub
        return longest
    
    def find_palindrome_from(self, string, left, right):
        while left >= 0 and right < len(string) and string[left] == string[right]:
            left -= 1
            right += 1
        return string[left + 1 : right]
        
class Solution(object):
    def longestPalindrome(self, s):
        if not s:
            return ''
        
        res = ''
        for i in range(len(s)):
            res = max(self.helper(s, i, i), self.helper(s, i, i + 1), res, key = len)
        return res
    
    def helper(self, s, left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left + 1 : right]
            
            
