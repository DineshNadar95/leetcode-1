原来输入数组中的 graph[i]，表示顶点i所有相邻的顶点，比如对于例子1来说，顶点0和顶点1，3相连，顶点1和顶点0，2相连，顶点2和结点1，3相连，
这道题让我们验证给定的图是否是二分图，所谓二分图，就是可以将图中的所有顶点分成两个不相交的集合，使得同一个集合的顶点不相连。
为了验证是否有这样的两个不相交的集合存在，我们采用一种很机智的染色法，大体上的思路是要将相连的两个顶点染成不同的颜色，
一旦在染的过程中发现有两连的两个顶点已经被染成相同的颜色，说明不是二分图。
这里我们使用两种颜色，分别用1和 -1 来表示，初始时每个顶点用0表示未染色，
然后遍历每一个顶点，如果该顶点未被访问过，则调用递归函数，如果返回 false，那么说明不是二分图，则直接返回 false。
如果循环退出后没有返回 false，则返回 true。
在递归函数中，如果当前顶点已经染色，如果该顶点的颜色和将要染的颜色相同，则返回 true，否则返回 false。
如果没被染色，则将当前顶点染色，然后再遍历与该顶点相连的所有的顶点，调用递归函数，
如果返回 false 了，则当前递归函数的返回 false，循环结束返回 true，

# 遍历整个图, 将相邻的节点染成不同的颜色, 如果可以完成这个遍历(即染色过程没有冲突), 说明是二分图.
# 可以用BFS或DFS来实现, 只需要根据当前节点的颜色设定下一个节点的颜色即可, 如果下一个节点已经被染成了相同的颜色, 说明发生了冲突.

# BFS 时间复杂度是O(E+V)，空间复杂度是O(V).

#DFS
class Solution(object):
    def isBipartite(self, graph):
        """
        :type graph: List[List[int]]
        :rtype: bool
        """
        n = len(graph)
        self.color = [0] * n
        for i in range(n):
            if self.color[i] == 0 and not self.colored(graph, i, 1):
                return False
        return True
    
    
    def colored(self, graph, current, color):
        self.color[current] = color
        for neighbor in graph[current]:
            if self.color[neighbor] == 0 and not self.colored(graph, neighbor, -color):
                return False
            elif self.color[neighbor] == self.color[current]:
                return False
        return True
