# recursion  TLE
# time O(2^n)
# space O(n)
class Solution(object):
    def findTargetSumWays(self, nums, S):
        """
        :type nums: List[int]
        :type S: int
        :rtype: int
        """
        if not nums:
            return 0
        
        self.res = 0
        self.dfs(nums, 0, S)
        return self.res
        
    def dfs(self, nums, start, target):
        if start >= len(nums):
            if target == 0:
                self.res += 1
            return 

        self.dfs(nums, start + 1, target - nums[start])
        self.dfs(nums, start + 1, target + nums[start])
        
        
# sol2 
# time O(l *n) l: range of sum, n:nums size，since the memomemo array of size l*nl∗n has been filled just once. 
# space O(n) the depth of recursion

recursion + memo
class Solution(object):
    def findTargetSumWays(self, nums, S):
       
        if not nums:
            return 0
        
        # key: start (index, sum), value = count 从start
        self.dic = collections.defaultdict(int)
        return self.dfs(nums, 0, 0, S)
    
    def dfs(self, nums, start_index, cur_sum, target):
        if (start_index, cur_sum) not in self.dic:
            res = 0
            
            # base case
            if start_index == len(nums):
                if cur_sum == target:
                    return 1
            else:
                res = self.dfs(nums, start_index + 1, cur_sum + nums[start_index], target) + self.dfs(nums, start_index + 1, cur_sum - nums[start_index], target)
                
            self.dic[(start_index, cur_sum)]  = res
        return self.dic[(start_index, cur_sum)]
        
            
           

# dp
DP: time O(n * S)
space O(s)
count key:sum, value:ways
class Solution(object):
    def findTargetSumWays(self, nums, S):
        """
        :type nums: List[int]
        :type S: int
        :rtype: int
        """
        # key:sum, value:count
        count = collections.defaultdict(int)
        count[0] = 1
        
        for num in nums:
            # key: current sum, value:current count
            dic = collections.defaultdict(int)
            for tmp in count:
                dic[tmp + num] += count[tmp]
                dic[tmp - num] += count[tmp]
            count = dic
            
        return count[S]
