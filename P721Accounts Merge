# bfs/dfs

# step: build graph, for each account, draw edge between first email to each of the other emails in the same account, 
and build hashtable for every email and name pair, hash table key: email, value:name
# bfs/dfs 寻找联通块

# time O(sum ai log ai), sort email for the last result
# space O(sum ai)

# ai 每个账户的长度

class Solution(object):
    def accountsMerge(self, accounts):
        """
        :type accounts: List[List[str]]
        :rtype: List[List[str]]
        """
        # build graph
        em_to_name = {}
        graph = collections.defaultdict(set)
        for account in accounts:
            name = account[0]
            for em in account[1:]:
                graph[account[1]].add(em)
                graph[em].add(account[1])
                em_to_name[em] = name
        
        
        # bfs traverse
        res = []
        visited = set()
        for em in graph:
            if em not in visited:  
                component = []
                queue = collections.deque([em])
                visited.add(em)
                while queue:
                    node = queue.popleft()
                    component.append(node)
                    for nb in graph[node]:
                        if nb not in visited:
                            queue.append(nb)
                            visited.add(nb)
                res.append([em_to_name[em]] + sorted(component))
        return res
                





# 我们可以将每个邮箱作为一个节点，同一个原始账户中的邮箱之间连边。并用老大 哥节点存储用户名

class Solution:
    """
    @param accounts: List[List[str]]
    @return: return a List[List[str]]
    """
    def accountsMerge(self, accounts):
        self.initialize(len(accounts))
        email_to_ids = self.get_email_to_ids(accounts)
        
        # union
        for email, ids in email_to_ids.items():
            root_id = ids[0]
            for id in ids[1:]:
                self.union(id, root_id)
                
        id_to_email_set = self.get_id_to_email_set(accounts)
        
        merged_accounts = []
        for user_id, email_set in id_to_email_set.items():
            merged_accounts.append([
                accounts[user_id][0],
                *sorted(email_set),
            ])
        return merged_accounts
    
    def get_id_to_email_set(self, accounts):
        id_to_email_set = {}
        for user_id, account in enumerate(accounts):
            root_user_id = self.find(user_id)
            email_set = id_to_email_set.get(root_user_id, set())
            for email in account[1:]:
                email_set.add(email)
            id_to_email_set[root_user_id] = email_set
        return id_to_email_set
            
    def get_email_to_ids(self, accounts):
        email_to_ids = {}
        for i, account in enumerate(accounts):
            for email in account[1:]:
                email_to_ids[email] = email_to_ids.get(email, [])
                email_to_ids[email].append(i)
        return email_to_ids
        
    def initialize(self, n):
        self.father = {}
        for i in range(n):
            self.father[i] = i
            
    def union(self, id1, id2):
        self.father[self.find(id1)] = self.find(id2)

    def find(self, user_id):
        path = []
        while user_id != self.father[user_id]:
            path.append(user_id)
            user_id = self.father[user_id]
            
        for u in path:
            self.father[u] = user_id
            
        return user_id


