首先将矩阵的左上角（下标0,0）元素加入堆
然后执行k次循环：
弹出堆顶元素top，记其下标为i, j
将其下方元素matrix[i + 1][j]，与右方元素matrix[i][j + 1]加入堆（若它们没有加入过堆）

# time O(klgk)
# space O(k)
 缺点，当k -> n ^2, time complexity很大


class Solution(object):
    def kthSmallest(self, matrix, k):
        """
        :type matrix: List[List[int]]
        :type k: int
        :rtype: int
        """
        result, heap = None, []
        heapq.heappush(heap, (matrix[0][0], 0, 0))
        while k > 0:
            result, i, j = heapq.heappop(heap)
            # we go right only in the first row, 因为一个元素不能重复入堆
        
            if i == 0 and j + 1 < len(matrix):
                heapq.heappush(heap, (matrix[i][j + 1], i, j + 1))
            if i + 1 < len(matrix):
                heapq.heappush(heap, (matrix[i + 1][j], i + 1, j))
            k -= 1
        return result
        
        
# binary search
# time O(Nlg(max - min))
二分过程查找区间中点 mid 在矩阵中的排名, 假设为 t , since the array is sorted, we can do it in O(N)
若 t == k, 该点即是结果
若 t > k, 区间变成 [l, mid - 1]
若 t < k, 区间变成 [mid + 1, r]

class Solution(object):
    def kthSmallest(self, matrix, k):
        """
        :type matrix: List[List[int]]
        :type k: int
        :rtype: int
        """
        left = matrix[0][0]
        right = matrix[-1][-1]
        
        while left < right:
            mid = (left + right) // 2
            smaller = matrix[0][0]
            larger = matrix[-1][-1]
            count, smaller, larger = self.count_less_equal(mid, smaller, larger, matrix)
            
            if count == k:
                return smaller
            elif count < k:
                left = larger
            else:
                right = smaller
        return left
    
    def count_less_equal(self, mid, smaller, larger, matrix):
        n = len(matrix)
        row = n - 1
        col = 0
        count = 0
        while row >= 0 and col < n:
            # find the smallest larger than mid
            if matrix[row][col] > mid:
                larger = min(larger, matrix[row][col])
                row -= 1
            else:
                # find the largest value smaller/equal to mid, and track count
                smaller = max(smaller, matrix[row][col])
                count += row + 1
                col += 1
        return count, smaller, larger
                
            
            
            

