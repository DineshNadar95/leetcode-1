# prob1 

# num = 6
# skills = [12, 4, 6, 13, 5, 10]
# minAssociates = 3
# minLevel = 4
# maxLevel = 10


# numAsso >= 3
# [4, 6, 5, 10]

# num = 3
# num = 4 

class Solution(object):
    def combination(self, num, skills, minAsso, minL, maxL):
        new_skills = []
        for skill in skills:
            if skill >= minL and skill <= maxL:
                new_skills.append(skill)
        
        candidates = []
        if minAsso > len(new_skills):
            return 0
        candidates = [x for x in range(minAsso,(len(new_skills) + 1))]
        
        print(new_skills, candidates)
        self.res = 0
        for ele in candidates:  
            self.dfs(new_skills, 0, 0, ele)
        return self.res
    
# [4, 6, 5, 10]

# num = 3 / 4
# num = 4 
    def dfs(self, nums, cur_num, start_index, count):
        
        if cur_num == count:
            self.res += 1
            return 
        
        if not nums:
            return 
        
        for i in range(start_index, len(nums)):
            self.dfs(nums[:i] + nums[i + 1:], cur_num + 1, i, count)
            
        #self.dfs(nums, cur_num + 1, cur_index, count)
        #self.dfs(nums, cur_num, cur_index + 1, count)
        
            
test = Solution()
print(test.combination(6, [12, 4, 6, 13, 5, 10], 3, 4, 10))


import heapq

def maxUnits(num, boxes, unitSize, unitsPerBox, truckSize):
    heap = []

    for i in range(len(boxes)):
        units_per_box = unitsPerBox[i]
        heapq.heappush(heap, (-units_per_box, boxes[i]))

    res = 0

    while truckSize > 0 and heap:
        curr_max = heapq.heappop(heap)
        max_boxes = min(truckSize, curr_max[1])
        truckSize -= max_boxes
        res += max_boxes * (curr_max[0] * -1)
    
    return res


# test cases
print(maxUnits(3, [1,2,3], 3, [3,2,1], 3))
print(maxUnits(3, [2,5,3], 3, [3,2,1], 50))
    
               
# s = "11373"

# [11, 37, 3), [113, 7, 3), [11, 3, 73), [11, 37, 3), (113, 73) and [11, 373)
class Solution(object):
    def splitString(self, s):
        self.res = 0
        self.dfs(s, 0)
        return self.res
    
    def dfs(self, s, index):
        if index == len(s):
            self.res += 1
            return 
            
        if s[index] == '0':
            return 
        
        for i in range(index, len(s)):
            if self.isPrime(int(s[index : i + 1])):
                self.dfs(s, i + 1)
                
    def isPrime(self, n): 
  
        # Corner cases 
        if n <= 1 : 
            return False
        if n <= 3: 
            return True
  
    # This is checked so that we can skip  
    # middle five numbers in below loop 
        if (n % 2 == 0 or n % 3 == 0) : 
            return False
  
        i = 5
        while(i * i <= n) : 
            if (n % i == 0 or n % (i + 2) == 0) : 
                return False
            i = i + 6
  
        return True

test = Solution()
print(test.splitString("11373"))
  
            
