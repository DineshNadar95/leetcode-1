1.	Get top K

我拿到的是说会有一个（公司名，值）的数据流，让你实现加值进去（如果公司已经存在了就把值加上去）和返回topK股票价值的公司
第一个是add vol 给的 ticker 和 vol， 比如amzn 本来是 300，给amzn 500后 amzn 得对应 800， 第二个接口是返还 top k 要求sorted

思路:
'''
# sol1: heap + hashmap
# initial heapify, time O(n)
# time: update : pop stock from heap, add new to heap, O(n), if not in dic, update O(lgn) 

# sol2 : hashtable + double linked list
# initial hashtable, sort by values, and build k size linked list, smallest is head, O(nlgn)  
# update: O(k)
case 1: update one in top k      
    remove the node from linked list
    compare from smallest
    insert/add
    
    2. not in top k
    compare from smallest O(k)
    insert/add O(1)
'''
# sol1: heap + hashtable, # key: name, val: stock node in heap

from heapq import * 
import collections
class StockSystem(object):
    def __init__(self, stocks):
        self.dic = {}  # key: name, val: stock node in heap
        self.heap = []
        for (stock, vol) in stocks:
            entry = [-vol, stock]
            self.heap.append(entry)
            self.dic[stock] = entry
            
        heapify(self.heap)
                
    def update(self, stock, vol):
        if stock in self.dic:
            self.dic[stock][0] -= vol
            heapify(self.heap)    
        else:
            new = [-vol, stock]
            heappush(self.heap, new)
            self.dic[stock] = new
                     
        
    def get_top_k(self, k):
        res = self.heap[:k]
        res = [[x[1], -x[0]] for x in res]
        return res
    

test = StockSystem([('Amazon', 500), ('Facebook',800), ('Google', 1000)])
print(test.get_top_k(2))
test.update('Amazon', 700)
print(test.get_top_k(2))
test.update('Microsoft', 2000)
print(test.get_top_k(2))

# sol2, two hashtable + linked list
# dic1: key: stock, val: vol
# dic2: key: stock, val: linked list node 
# initialize :time O(nlgn)
# update: time O(k)

from heapq import * 
import collections

class ListNode(object):
    def __init__(self, stock, vol):
        self.stock = stock
        self.vol = vol
        self.prev = None
        self.next = None
        
class StockSystem(object):
    def __init__(self, stocks, k):
        self.dic = {}  # key: name, val: stock node in heap
        self.dic_node = {} # key: stock, val: list node 
        self.heap = []
        self.dummy_head = ListNode('', 0)      
        self.dummy_tail = ListNode('', 0)
        self.dummy_head.next = self.dummy_tail
        self.dummy_tail.prev = self.dummy_head
        
        
        l = []
        for s, v in stocks:
            self.dic[s] = v
            l.append([s, v])
            
        l.sort(key = lambda x:-x[1])
        cur = self.dummy_head
        
        for i in range(k):
            stock, vol = l[i]
            node = ListNode(stock, vol)
            node.prev = cur
            cur.next = node
            cur = cur.next
            self.dic_node[stock] = node
        cur.next = self.dummy_tail # tail is smallest
        self.dummy_tail.prev = cur
        
            
    def update(self, stock, vol):
        if stock in self.dic_node:
            self.delete[self.dic_node[stock]]
            
        prev_val = self.dic[stock]
        cur_val = prev_val + vol
        self.dic[stock] = cur_val
        
        
        if cur_val > self.dummy_tail.prev.vol:
            # find first node such that cur_val > node.val
            node = ListNode(stock, cur_val)
            cur = self.dummy_head.next
            while cur.next.vol > cur_val:
                cur = cur.next
            self.insert(cur, node)
            self.dic[stock] = node
    
        
    def get_top_k(self, k):
        res = []
        cur = self.dummy_head.next
        
        for _ in range(k):
            res.append([cur.stock, cur.vol])
            cur = cur.next
        return res
            
    
    def delete(self, node): # remove tail
        prev = node.prev
        nxt = node.next
        prev.next = nxt
        nxt.prev = prev
        
    def insert(self, node, new):
        nxt = node.next
        node.next = new
        new.prev = node
        new.next = nxt
        nxt.prev = new
        
        
        

test = StockSystem([('Amazon', 500), ('Facebook',800), ('Google', 1000)], 2)
print(test.get_top_k(2))
test.update('Amazon', 700)
print(test.get_top_k(2))


2. # 找括号深度最深的元素e.g. (((ab))(c)) return ab, 

# stack 
# '(' , depth + 1
# ')' , depth - 1
# dic: key, depth , value:char

class Solution(object):
    def findDeepstChars(self, s):
        dic = {} # key: depth, value: char
        depth = 0
        for char in s:
            if char == '(':
                depth += 1

            elif char == ')':
                depth -= 1
            
            else: 
                dic[depth] = dic.get(depth, '') + char
                
        max_depth = max(dic.keys())
        print(dic)
        return dic[max_depth]
    
test = Solution()
print(test.findDeepstChars('(((ab))(c))'))
        
                
        

        
