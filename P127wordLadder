BFS

# time O(m*n)
# space O(m * n)
time : where MM is the length of words and NN is the total number of words in the input word list. 
Finding out all the transformations takes MM iterations for each of the NN words. 
Also, breadth first search in the worst case might go to each of the NN words.

space : to store all MM transformations for each of the NN words, 
in the all_combo_dict dictionary. Visited dictionary is of NN size. 
Queue for BFS in worst case would need space for all NN words.


class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        
        wordset = set(wordList)
        queue = collections.deque([(beginWord, 1)])
        while queue:
            word, length = queue.popleft()
            if word == endWord:
                return length
            for i in range(len(word)):
                for c in 'abcdefghijklmnopqrstuvwxyz':
                    new_word = word[:i] + c + word[i + 1:]
                    if new_word in wordset and new_word != word:
                        queue.append((new_word, length + 1))
                        wordset.remove(new_word)
        return 0
