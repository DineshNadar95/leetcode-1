# time O(n^2)
# space O(n)

# maintain dic, key:slope, value counts 
# iterate each point, 
# for j in range(i + 1, n)
# take care of duplicate points


计算斜率: x1 == x2 斜率是无穷大；Decimal 解决浮点数精度问题；注意duplicate

from decimal import Decimal

from decimal import Decimal

class Solution(object):
    def maxPoints(self, points):
        # corner case
        if len(points) < 3:
            return len(points)
        
        res = 0
        n = len(points)
        
        # 计算通过当前点的最多点的数量，dic: slope, value: points on the current slope (not include point i)
        for i in range(len(points) - 1):
            dic = collections.defaultdict(int)
            dup = 1
            res_i = 0
            for j in range(i + 1, len(points)):
                if points[j][0] == points[i][0] and points[j][1] == points[i][1]:
                    dup += 1
                    continue
                if points[i][0] == points[j][0]:
                    slope = sys.maxsize
                else:
                    slope = Decimal(points[j][1] - points[i][1]) / Decimal(points[j][0] - points[i][0])
                dic[slope] += 1
                
            if dic:
                res_i = max(max(dic.values()) + dup, res_i)
            else:
                res_i = max(dup, res_i)
                
            res = max(res, res_i)
        return res
