# time O(n^2)
# space O(n)

# maintain dic, key:slope, value counts 
# iterate each point, 
# for j in range(i + 1, n)
# take care of duplicate points


计算斜率: x1 == x2 斜率是无穷大；Decimal 解决浮点数精度问题；注意duplicate

from decimal import Decimal

class Solution(object):
    def maxPoints(self, points):
        # corner case
        if len(points) < 3:
            return len(points)
        
        res = 0
        n = len(points)
        
        for i in range(len(points) - 1):
            dic = collections.defaultdict(int)
            dup = 1
            for j in range(i + 1, len(points)):
                if points[j][0] == points[i][0] and points[j][1] == points[i][1]:
                    dup += 1
                    continue
                if points[i][0] == points[j][0]:
                    slope = sys.maxsize
                else:
                    slope = Decimal(points[j][1] - points[i][1]) / Decimal(points[j][0] - points[i][0])
                    
                dic[slope] += 1
            res = max(res, (max(dic.values()) if dic else 0) + dup)
        return res
                    
