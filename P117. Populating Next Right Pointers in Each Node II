# queue
# time O(n), space O(n)
class Solution(object):
    def connect(self, root):
        
        if not root:
            return None
        q = collections.deque([root])
        
        while q:
            n = len(q)
            cur = q.popleft()
            if cur.left:
                q.append(cur.left)
            if cur.right:
                q.append(cur.right)
            
            for _ in range(n - 1):
                node = q.popleft()
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
                cur.next = node
                cur = node
                
        return root
                
        

# iterative
# time O(n), space O(1)
idea:
一旦在某层的节点之间建立了 next 指针，那这层节点实际上形成了一个链表。基于该想法，提出降低空间复杂度的思路：
第 N 层节点之间建立 next 指针后，再建立第 N+1 层节点的 next 指针。
因为可以通过 next 指针访问同一层的所有节点，所以使用第 N 层的 next 指针可以为第 N+1 层节点建立 next 指针。

class Solution(object):
    def connect(self, root):
        if not root:
            return None
        
        left_most = root 
        level_head = Node(0)
        
        while left_most:  
            cur = left_most
            prev = level_head
            
            while cur:  
                if cur.left:
                    
                    prev.next = cur.left     
                    prev = prev.next        

                if cur.right:
                    prev.next = cur.right
                    prev = prev.next

                cur = cur.next
            
            left_most = level_head.next       
            level_head.next = None        
        return root


class Solution(object):
    def connect(self, root):
        
        node = root 
        levelHead = Node(0)
        
        while node:  # loop for each level
            needle = levelHead
            
            while node:  # loop for current level
                if node.left:
                    
                    needle.next = node.left     # since needle and levelHead points to the same object. That means after needle.next = node.left. 
                    needle = needle.next        # Same for levelHead.next = node.left. 
                                                # this is how levelHead move to next level
                    
                if node.right:
                    needle.next = node.right
                    needle = needle.next

                node = node.next
            
            node = levelHead.next       # this is key part. as said before, levelHead.next = node.left
            levelHead.next = None        # so that node moves to its upper level's leftmost node's left child. meaning the head of this next level
            
        return root
     
     
     
     
 class Solution(object):
    def connect(self, root):
        
        if not root:
            return None
        
        node = root
        level_head = Node(0)
        
        while node:
            needle = level_head
            
            while node:
                if node.left:
                    needle.next = node.left
                    needle = needle.next
                
                if node.right:
                    needle.next = node.right
                    needle = needle.next
                
                node = node.next
            node = level_head.next
            level_head.next = None
        return root
