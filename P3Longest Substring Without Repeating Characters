# two pointers + hashset (sliding window)
# sliding windown keep the subtring with unique char

变量start和end分别记录子串的起点和终点
从左向右逐字符遍历原始字符串，每次将end + 1
字典countDict存储当前子串中各字符的个数
当新增字符c的计数 > 1时，向右移动起点start，并将s[start]在字典中的计数 - 1，直到countDict[c]不大于1为止
更新最大长度

# time O(n), worst case is that each char is visited twice by i and j
# space O(k) (k is the length of set)

class Solution(object):
    def lengthOfLongestSubstring(self, s):
        i = 0
        j = 0
        dic = {}
        max_len = 0
        
        for i in range(len(s)):
            while j < len(s) and s[j] not in dic:
                dic[s[j]] = 1
                j += 1
                
            # cur_l = s[i : j]
            max_len = max(max_len, j - 1 - i + 1)
            
            if dic[s[i]] > 1:
                dic[s[i]] -= 1
            else:
                del dic[s[i]]
                
        return max_len
            
            
