# two pointers + hashset (sliding window)

# hashsest the unique char in the sliding window

# sliding windown keep the subtring with unique char

变量start和end分别记录子串的起点和终点
从左向右逐字符遍历原始字符串，每次将end + 1
字典countDict存储当前子串中各字符的个数
当新增字符c的计数 > 1时，向右移动起点start，并将s[start]在字典中的计数 - 1，直到countDict[c]不大于1为止
更新最大长度

# time O(n), space O(k) (k is the length of set)

class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:

        length = 0
        fast = 0
        unique_char = set([])
        
        for slow in range(len(s)):
            while fast < len(s) and s[fast] not in unique_char:
                unique_char.add(s[fast])
                fast += 1
            length = max(length, fast - slow)
            unique_char.remove(s[slow])
                
        return length
                
