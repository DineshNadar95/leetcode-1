# recursion + memorization
# input is stirng, memory
# ouput is the minumum delele times of the string
# check if it is <= k

# time O(n^2)
# space O(n)

class Solution(object):
    def isValidPalindrome(self, s, k):
        return self.dfs(s, {}) <= k
    
    def dfs(self, s, memo):
        if s in memo:
            return memo[s]
        
        if not s:
            return 0
        
        left = 0
        right = len(s) - 1
        res = 0
        while left < right:
            if s[left] == s[right]:
                left += 1
                right -= 1
                
            else:
                # choose delete left or right
                res = 1 + min(self.dfs(s[left + 1 : right + 1], memo), self.dfs(s[left : right], memo))
                memo[s] = res
                return res
        memo[s] = res
        return res
                

# dp
thanks !
same thoughts
edit distance where only deletion is allowed between s and reversed(s)

if one of them is empty we have to delete the entire other
if last character is the same then no need to delete any of these last 2
if last characters are not the same then delete either or

the distance == total number of deletions in one string + total number of deletions in the other
implies it has to be <= 2 * k
(removing at most k in each)

class Solution(object):
    def isValidPalindrome(self, s, k):
        """
        :type s: str
        :type k: int
        :rtype: bool
        """
        n = len(s)
        dp = [[0] * (n + 1) for _ in range(n + 1)] 
        for i in range(n + 1): 
            for j in range(n + 1): 
                if not i or not j: 
                    dp[i][j] = i or j 
                elif s[i - 1] == s[n - j]: 
                    dp[i][j] = dp[i - 1][j - 1] 
                else: 
                    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1])
        return dp[n][n] <= k * 2


