# BFS topo sort
# Time Complexity: build graph, two for loops O(len(words) * len(word))
Topological sort takes O(V + E). V <= n. E also can't be larger than n. So the overall time complexity is O(n).
# space O(V)



class Solution(object):
    def alienOrder(self, words):
        
        # step1: add nodes
        nodes = {}
        for word in words:
            for char in word:
                if char not in nodes:
                    nodes[char] = set()
         
        # step 2: add edges and calculate indegree for each node
        # 易错点1: indegree的定义方法
        indegrees = {n : 0 for n in nodes.keys()}    
        # add edge:
        for i in range(len(words) - 1):
            first = words[i]
            second = words[i + 1]
            compare_index = min(len(first), len(second))
            for j in range(compare_index):
                if first[j] != second[j]: # char1 -> char2(indegree + 1)
                    #易错点2， 先判断char2 是否在char1 的adjacent set里面
                    if second[j] not in nodes[first[j]]:
                        nodes[first[j]].add(second[j])
                        indegrees[second[j]] += 1
                    break
                    
         
        # step 3, topological sort
        queue = collections.deque([])
        for c, indeg in indegrees.items():
            if indeg == 0:
                queue.append(c)
                
        res = ''
        while queue:
            n = queue.popleft()
            res = res + n
            if nodes[n]:
                for nb in nodes[n]:
                    indegrees[nb] -= 1
                    if indegrees[nb] == 0:
                        queue.append(nb)
        
        if len(res) == len(nodes):
            return res
        return ''
            
                    
                
    
    
        
    
                    
                
            
                           
                                
                           
