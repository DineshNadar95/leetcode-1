# BFS topo sort
# Time Complexity: Say the number of characters in the dictionary (including duplicates) is n. 
Building the graph takes O(n). 
Topological sort takes O(V + E). V <= n. E also can't be larger than n. So the overall time complexity is O(n).



class Solution:
    def alienOrder(self, words):        
        graph = self.build_graph(words)
        return self.bfs(graph)
        
    def build_graph(self, words):
        graph = {}
        
        # add vertice
        for word in words:
            for char in word:
                if char not in graph:
                    graph[char] = set()
                    
        # add edges
        length = len(words)
        for i in range(length - 1):
            first = words[i]
            second = words[i + 1]
            for j in range(min(len(first), len(second))):
                if first[j] != second[j]:
                    graph[first[j]].add(second[j])
                    break 
                    
        return graph
    
    def bfs(self, graph):
        in_degree = {node : 0 for node in graph}
        
        for v in graph:
            for neighbor in graph[v]:
                in_degree[neighbor] += 1
        
        queue  = collections.deque()
        for v2 in graph:
            if in_degree[v2] == 0:
                queue.append(v2)
                
    
        res = '' 
        while queue:
            node = queue.popleft()
            res += node
            for neighbor in graph[node]:
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)
        
        if len(res) == len(graph):
            return res
        else:
            return ''
                
