# BFS topo sort
# Time Complexity: build graph, two for loops O(len(words) * len(word))
Topological sort takes O(V + E). V <= n. E also can't be larger than n. So the overall time complexity is O(n).
# space O(V)



import collections
class Solution(object):
    def alienOrder(self, words):
        result  = self.build_graph(words)
        graph = result[0]
        indegrees = result[1]
        
        return self.bfs(graph, indegrees)
    
    
    def build_graph(self, words):
        
        graph = {}
        # add vertex
        for word in words:
            for char in word:
                if char not in graph:
                    graph[char] = set()
                    
             
        # add edges
        indegrees = collections.defaultdict(int)
        n = len(words)
        for i in range(n - 1):
            first = words[i]
            second = words[i + 1]
            for j in range(min(len(first), len(second))):
                # 易错点1 ，first[j] -> second[j]，a->b, a.neighbor.append(b), b的入度+1
                if first[j] != second[j]:
                    # 易错点2 ，if second[j] not in graph[first[j]] 检查second[j]是否已经是在first[j]的邻居里，否则indegree会出错
                    if second[j] not in graph[first[j]]:
                        graph[first[j]].add(second[j])
                        indegrees[second[j]] += 1
                    break
        return graph, indegrees
    
    
    def bfs(self, graph, indegrees):
        queue = collections.deque([])
        for node in graph:
            if indegrees[node] == 0:
                queue.append(node)
        res = ''
        while queue:
            node = queue.popleft()
            res += node
            for neighbor in graph[node]:
                indegrees[neighbor] -= 1
                if indegrees[neighbor] == 0:
                    queue.append(neighbor)
        if len(res) == len(graph.keys()):
            return res
        else:
            return ''
        
test = Solution()
print(test.alienOrder(["wrt",
  "wrf",
  "er",
  "ett",
  "rftt"]))
            
                
            
    
    
        
    
                    
                
            
                           
                                
                           
