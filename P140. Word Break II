# dfs + memo (top down dp)
# Time complexity: O(n^3). Size of recursion tree can go up to n^2. The creation of the 'res' List takes n time.
# space complexity is also O(n ^ 3)

# memo: key: start index of substring, value: valid path

class Solution(object):
    def wordBreak(self, s, wordDict):
        
        self.words = set(wordDict)
        self.memo = {} # key, start index, value: valid paths
        return self.dfs(s, 0)
    
    def dfs(self, s, start):
        if start in self.memo:
            return self.memo[start]
        
        if start == len(s):
            self.memo[start] = []
            return []
        
        res = []
        for j in range(start + 1, len(s) + 1):
            if s[start : j] in self.words:
                if j == len(s):
                    res.append(s[start : j])
                else:
                    rests = self.dfs(s, j)
                    for rest in rests:
                        res.append(s[start : j] + ' ' + rest)
        self.memo[start] = res
        return res
        
# follow up  输出最小的分割次数
# time O(n^2)
# space O(n^2)

class Solution(object):
    def wordBreak(self, s, dic):
        return self.dfs(s, dic, 0, len(s) - 1, {})
    
    
    def dfs(self, s, dic, start, end, memo):
        if (start, end) in memo:
            return memo[(start, end)]
        
        res = sys.maxsize
        if s[start : end + 1] in dic:
            memo[(start, end)] = 1
            return 1
        
        for j in range(start, end):
            if s[start: j + 1] in dic:
                res = min(res,  1 +  self.dfs(s, dic, j + 1, end, memo))
                
        memo[(start, end)] = res
        return res
                

s = "pineapplepenapple"
dic =["apple", "pen", "applepen", "pine", "pineapple"]

test = Solution()
print(test.wordBreak(s, dic))
                                       
        
