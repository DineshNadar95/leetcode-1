# dfs + memo (top down dp)
# Time complexity: O(n^3). Size of recursion tree can go up to n^2. The creation of the 'res' List takes n time.
# space complexity is also O(n ^ 3)


class Solution(object):
    def wordBreak(self, s, wordDict):
        
        self.dic = {}
        return self.dfs(s, 0, wordDict)
        
        
    def dfs(self, s, cur_index, wordDict):
        if cur_index in self.dic:
            return self.dic[cur_index]
        
        if cur_index == len(s):
            self.dic[cur_index] = []
            return []
        
        res = []
        for j in range(cur_index, len(s)):
            if s[cur_index : j + 1] in wordDict:
                if j + 1 == len(s):
                    res.append(s[cur_index : j + 1])
                else:
                    rests = self.dfs(s, j + 1, wordDict)
                    for rest in rests:
                        res.append(s[cur_index : j + 1] + ' ' + rest)
        self.dic[cur_index] = res
        return res
                
        
# follow up  输出最小的分割次数
class Solution(object):
    def wordBreak(self, s, dic):
        
        return self.dfs(s, dic, 0, len(s) - 1, {})
    
    
    def dfs(self, s, dic, start, end, memo):
        if (start, end) in memo:
            return memo[(start, end)]
        
        res = sys.maxsize
        if s[start : end + 1] in dic:
            memo[(start, end)] = 1
            return 1
        
        for j in range(start, end):
            if s[start: j + 1] in dic:
                res = min(res,  1 +  self.dfs(s, dic, j + 1, end, memo))
                
        memo[(start, end)] = res
        return res
                

s = "pineapplepenapple"
dic =["apple", "pen", "applepen", "pine", "pineapple"]

test = Solution()
print(test.wordBreak(s, dic))
                                       
        
