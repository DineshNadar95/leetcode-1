# dfs + memo (top down dp)
# Time complexity: O(2^n). Size of recursion tree can go up to 2^n. The creation of the 'res' List takes n time.
# space complexity is also O(2^n), since we have O(2^n) possible res


class Solution(object):
    def wordBreak(self, s, wordDict):
        
        word_dic = set(wordDict)
        return self.dfs(s, word_dic, 0, {})
        
    
    def dfs(self, s, word_dic, start, memo):
        if start in memo:
            return memo[start]
        
        if start == len(s):
            memo[start] = []
            return memo[start]
        
        res = []
        for end in range(start + 1, len(s) + 1):
            if s[start : end] in word_dic:
                if end == len(s):
                    res.append(s[start : end])
                else:
                    rests = self.dfs(s, word_dic, end, memo)
                    for rest in rests:
                        if rest:
                            res.append(s[start : end] + ' ' + rest)
        memo[start] = res
        return res
                
        
            
        
