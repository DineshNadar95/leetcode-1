# dfs + memo (top down dp)
# Time complexity: O(n^3). Size of recursion tree can go up to n^2. The creation of the 'res' List takes n time.
# space complexity is also O(n ^ 3)


class Solution(object):
    def wordBreak(self, s, wordDict):
        
        self.dic = {}
        return self.dfs(s, 0, wordDict)
        
        
    def dfs(self, s, cur_index, wordDict):
        if cur_index in self.dic:
            return self.dic[cur_index]
        
        if cur_index == len(s):
            self.dic[cur_index] = []
            return []
        
        res = []
        for j in range(cur_index, len(s)):
            if s[cur_index : j + 1] in wordDict:
                if j + 1 == len(s):
                    res.append(s[cur_index : j + 1])
                else:
                    rests = self.dfs(s, j + 1, wordDict)
                    for rest in rests:
                        res.append(s[cur_index : j + 1] + ' ' + rest)
        self.dic[cur_index] = res
        return res
                
        
            
        
