# 序列化
# for each node + hash table, key: serialization of subtree, value: times

# time O(n ^ 2)
# space O(n ^ 2)



 class Solution(object):
    def findDuplicateSubtrees(self, root):
        self.paths = collections.defaultdict(int)
        self.res = []
        self.dfs(root)
        return self.res
    
    
    def dfs(self, node):
        if not node:
            return '#'
        
        path = str(node.val) + ',' self.dfs(node.left) + ',' + self.dfs(node.right)
        if self.paths[path] == 1:
            self.res.append(node)
        self.paths[path] += 1
        return path


# sol2 
# assign a unique id for each unique substree
# time O(n)
# space O(n)

don't need to storage serialization of subtree, can use key(root.val, id(leftChild), id(rightChild))
# default_factory is a function returning the default value for the dictionary defined.

class Solution(object):
    def findDuplicateSubtrees(self, root):
        
        self.dic = collections.defaultdict(int)
        self.count = collections.defaultdict(int)
        self.res = []
        self.lookup(root)

        return self.res

    def lookup(self, node):
        if not node:
            return 0
            
        seris = (node.val, self.lookup(node.left), self.lookup(node.right))
        if seris in self.dic:
            uid = self.dic[seris]
        else:
            uid = self.dic[seris] = len(self.dic) + 1
        self.count[uid] += 1
        if self.count[uid] == 2:
            self.res.append(node)
        return uid
