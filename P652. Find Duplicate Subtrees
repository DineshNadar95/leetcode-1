# 序列化
# for each node + hash table, 
#  dic, key:serialization of current node, value: times

# time O(n ^ 2)
# space O(n ^ 2)

 class Solution(object):
    def findDuplicateSubtrees(self, root):
        
        if not root:
            return None
        
        self.dic = collections.defaultdict(int)
        self.res = []
        self.dfs(root)
        return self.res
    
    def dfs(self, node): # return seris result 
        if not node:
            return '#'
        
        seris = str(node.val) + ',' + self.dfs(node.left) + ',' + self.dfs(node.right) 
        self.dic[seris] += 1
        if self.dic[seris] == 2:
            self.res.append(node)
            
        return seris

# sol2 
# assign a unique id for each unique substree
# time O(n)
# space O(n)

don't need to storage serialization of subtree, can use key(root.val, id(leftChild), id(rightChild))
# default_factory is a function returning the default value for the dictionary defined.

class Solution(object):
    def findDuplicateSubtrees(self, root):
        
        if not root:
            return None
        
        self.dic = collections.defaultdict(int) # key, node, value unique id
        self.count = collections.defaultdict(int) # key, id, value: count
        self.res = []
        self.dfs(root)
        return self.res
    
    def dfs(self, node):
        if not node:
            return 0
        
        seris = (node.val, self.dfs(node.left), self.dfs(node.right))
        if seris in self.dic:
            uid = self.dic[seris]
        else:
            uid = len(self.dic) + 1
            self.dic[seris] = uid
        
        self.count[uid] += 1
        if self.count[uid] == 2:
            self.res.append(node)
        return uid
