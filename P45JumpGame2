# greedy

# 只需要在一次 跳跃 完成时，更新下一次 能跳到最远的距离。

# 使用一个cur表示当前步能到达的最远位置，使用pre表示上一次能到达的最远位置。
# 所以，我们应该遍历在上一步的覆盖范围内，当前能跳的最远位置来更新cur。
# 一个节省计算资源的方式是，保存以前已经检查了的位置为Pos，这样每次检查的范围是pos~pre。
# time O(n)
# space O(1)

class Solution(object):
    def jump(self, nums):
       
        end = 0 # end 表示当前能跳的边界
        max_pos = 0
        steps = 0
        for i in range(len(nums) - 1):
            max_pos = max(max_pos, nums[i] + i) //找能跳的最远的
            if i == end: //遇到边界，就更新边界，并且步数加一
                end = max_pos
                steps += 1
        return steps
