# dfs
# time m * n^n
# space O(n)

class Solution(object):
    def findAllConcatenatedWordsInADict(self, words):
        """
        :type words: List[str]
        :rtype: List[str]
        """
        words = set(words)
        
        def isConcad(word):
            for i in range(1, len(word)):
                if word[:i] in words and (word[i:] in words or isConcad(word[i:])):                 
                                          return True
            return False
                                          
        return [word for word in words if isConcad(word)]    
        

class Solution(object):
   
    def findAllConcatenatedWordsInADict(self, words):
       
        s = set(words)
        
        memo = {}
        def isConcatenatedWord(w):
            if w in memo: return memo[w]
            
            for i in range(1, len(w)):
                if w[:i] not in s: continue
                
                r = w[i:]
                if r in s or isConcatenatedWord(r):
                    memo[w] = True
                    return True
                
            memo[w] = False
            return False
        
        return filter(isConcatenatedWord, words)
        
   
# dp
# 对于words中的每个单词w，定义一个数组dp[n+1]，如果dp[i] == true，则表示w[0:i]可以由words中的已有单词连接而成。
# 状态转移方程就是：dp[i] = || {dp[j] && w.substr(j + 1, i - j) is in words}，其中j < i。
# 最终检查dp[n]是否为true，如果是则将其加入结果集中。
# 为了加速对words中的单词的查找，用一个哈希表来保存各个单词。
# 这样时间复杂度可以降低到O(n * m^2)，其中n是words中的单词的个数，m是每个单词的平均长度（或者最大长度）。
